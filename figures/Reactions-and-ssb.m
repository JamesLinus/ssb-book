(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ToVec[Sym_,S_]:=Map[If[Sym==#1,1,0]&,S];

ExpToVec[expr_,S_]:=
If[StringQ[expr],
ToVec[expr,S],
If[!AtomQ[expr],
Map[ExpToVec[#1,S]&,expr],
expr]
];

CToY[y_,S_]:=Product[(Subscript[c, S[[i]]][t])^ y[[i]],{i,1,Length[S]}];

Kinetics[{LHS_,RHS_,k_},S_]:=k CToY[ExpToVec[LHS,S],S];

KineticsVector[{S_,R_}]:=Map[Kinetics[#,S]&,R];

rhs[i_,R_,S_,K_]:=Module[
{k},
Sum[
(ExpToVec[R[[k,2]],S]-ExpToVec[R[[k,1]],S])[[i]]K[[k]],
{k,1,Length[R]}
]
];

Eqns[{S_,R_}]:=With[
{K=Map[Kinetics[#1,S]&,R]},
Table[
If[First[Characters[S[[i]]]] =="c",
D[Subscript[c, S[[i]]][t],t]==0,
D[Subscript[c, S[[i]]][t],t]==Simplify[rhs[i,R,S,K]]
],
{i,1,Length[S]}
]
];

Inits[S_,x0_]:=Table[(Subscript[c, S[[i]]][0])==x0[[i]],{i,1,Length[S]}];

Vars[{S_,R_}]:=Table[(Subscript[c, S[[i]]]),{i,1,Length[S]}];

Varst[{S_,R_}]:=Table[(Subscript[c, S[[i]]])[t],{i,1,Length[S]}];

SimNet[{S_,R_},c0_,tf_,opts___]:=Module[
{sol},
sol=First[NDSolve[
Join[Eqns[{S,R}],Inits[S,c0]],
Vars[{S,R}],
{t,0,tf}]];
{Plot[Evaluate[Varst[{S,R}]/.sol],{t,0,tf},PlotStyle->Table[Hue[i/Length[S]],{i,1,Length[S]}],
PlotPoints->100,
Epilog->Table[
Text[S[[i]],{0.75i tf / Length[S],(Subscript[c, S[[i]]][0.75i tf / Length[S]])/.sol}],{i,1,Length[S]}
],opts
],
sol}
];


ReactionVector[r_,v_]:=ExpToVec[r[[2]],v]-ExpToVec[r[[1]],v];

StoichMat[{S_,R_}]:=Transpose[Map[ReactionVector[#1,S]&,R]];

ReactionMultiplicity[a_,v_]:=Module[
{i,m},
m=1;
For[i=1,i<=Length[a],i++,
m=m Binomial[v[[i]],Max[0,-a[[i]]]]
];
m
];

BasicRateVector[R_]:=Map[#1[[3]]&,R];

RateVec[R_,v_]:=Module[
{A,k},
A=Transpose[StoichMat[R,v]];
k=Map[#1[[3]]&,R];
Table[k[[i]] ReactionMultiplicity[A[[i]],v],{i,1,Length[R]}]
];


ValidState[v_]:=Apply[And,Map[(#>=0)&,v]];

EnumerateStates[{u_,R_},v0_,opts___]:=Module[
{S,unexp,v,next,i,Alist,n,con},
con=(Constraint/.{opts}/.{Constraint->(True&)});
n=1;
Alist=Transpose[StoichMat[{u,R}]];
S={};
unexp={v0};
While[n<1000\[And]unexp!={},
v=First[unexp];
n=n+1;
If[n>=1001,Print["Warning:Truncating at 1000 states"]];
unexp=Rest[unexp];
S=Append[S,v];
next=Map[(v+#)&,Alist];
For[i=1,i<=Length[next],i++,
If[con[next[[i]]]\[And]ValidState[next[[i]]]\[And]!MemberQ[S,next[[i]]]\[And]!MemberQ[unexp,next[[i]]],
unexp=Append[unexp,next[[i]]]
]
]
];
S
];

MacroStateIndex[S_,v_]:=With[{p=Position[S,v]},If[p!={},p[[1,1]],-1]];

NextStates[{s_,R_},v_,opts___]:=Module[
{L,i,u,A,k,K,vars,rep,rate,con},
con=con=(Constraint/.{opts}/.{Constraint->(True&)});
A=Transpose[StoichMat[{s,R}]];
k=BasicRateVector[R];
L={};
K={};
vars=Varst[{s,R}];
rep=Table[vars[[i]]->v[[i]],{i,1,Length[v]}];
For[i=1,i<=Length[A],i++,
u=v+A[[i]];
rate=Kinetics[R[[i]],s]/.rep;
If[con[u]\[And]ValidState[u]\[And](rate!=0\[Or]\[Not]NumberQ[rate]),
L=Append[L,u];
K=Append[K,rate];
];
];
{L,K}
];

RateMatrix[{S_,R_},v0_,opts___]:=Module[
{Q,n,i,X,k,ktot},
states=EnumerateStates[{S,R},v0,opts];
n=Length[states];
Q=Table[0,{n},{n}];
For[i=1,i<=n,i++,
{X,k}=NextStates[{S,R},states[[i]]];
ktot=0;
For[j=1,j<=Length[X],j++,
If[MacroStateIndex[states,X[[j]]]!=-1,
Q[[i,MacroStateIndex[states,X[[j]]]]]+=k[[j]];
ktot+=k[[j]]
];
];
Q[[i,i]]=-ktot;
];
Q
];

MapOutput[\[Sigma]_,f_]:=Map[{#[[1]],f[#[[2]]]}&,\[Sigma]]



Kolmogorov[Q_,x0_]:=Module[
{X,i,n,lhs,rhs},
n=Length[Q];
X=Table[Subscript[x, i][t],{i,1,n}];
inits=Table[Subscript[x, i][0]==x0[[i]],{i,1,n}];
lhs=D[X,t];
rhs=Transpose[Q].X;
{X,inits\[Union]Table[lhs[[i]]==rhs[[i]],{i,1,n}]}
];


ChooseNextState[v_,k_]:=Module[
{r,\[Mu],s,ktot},
ktot=Apply[Plus,k];
r=Random[Real,{0,1}]ktot;
\[Mu]=1;
s=k[[\[Mu]]];
While[r>=s,
\[Mu]=\[Mu]+1;
s=s+k[[\[Mu]]];
];
{v[[\[Mu]]],1/ktot Log[1/Random[Real,{0,1}]]}
]

SSA[v0_,nextstates_,tmax_,nmax_]:=Module[
{t,n,V,v,k,traj,\[Tau]},
t=0;
n=1;
v=v0;
traj={{0,v0}};
While[t<tmax\[And]n<nmax,
{V,k}=nextstates[v];
If[V=={},
n=nmax,
{v,\[Tau]}=ChooseNextState[V,k];
traj=Append[traj,{t+\[Tau],v}];
t=t+\[Tau];
n++
]
];
traj
]

MultiSSA[v0_,nextstates_,tmax_,nmax_,numtraj_]:=Table[SSA[v0,nextstates,tmax,nmax],{numtraj}];

BeautifyMarkovTraj[\[Sigma]_]:=Append[Apply[Join,Table[
{\[Sigma][[i]],{\[Sigma][[i+1,1]],\[Sigma][[i,2]]}},
{i,1,Length[\[Sigma]]-1}
]],Last[\[Sigma]]];

TrajFunction[\[Sigma]_,t_]:=Module[
{i,v},
i=1;
If[t>=Last[\[Sigma]][[1]],
v=Last[\[Sigma]][[2]],
While[\[Sigma][[i,1]]<= t,
i++;
];
v=\[Sigma][[i-1,2]];
];
v
]

MultiTrajFunction[\[CapitalSigma]_,t_]:=Apply[Plus,Map[TrajFunction[#,t]&,\[CapitalSigma]]]/Length[\[CapitalSigma]]
